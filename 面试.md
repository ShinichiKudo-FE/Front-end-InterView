# 浏览器兼容性问题

## window.location.href问题

说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;
Firefox1.5.x下,只能使用window.location.
解决方法：使用window.location来代替window.location.href.

## 自定义属性问题

问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute() 获取自定义属性；Firefox下，只能使用getAttribute() 获取自定义属性。
解决方法：统一通过getAttribute() 获取自定义属性。

## input.type属性问题

问题说明：IE下input.type属性为只读；但是Firefox下input.type属性为读写。
解决办法：不修改input.type属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。

## css中的width和padding

在IE7和FF中width宽度不包括padding，在Ie6中包括padding.

# 前端优化方法

## 减少http请求，合理设置 HTTP缓存

减少http的主要手段是合并CSS、合并javascript、合并图片。将浏览器一次访问需要的javascript和CSS合并成一个文件，这样浏览器就只需要一次请求。图片也可以合并，多张图片合并成一张，如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。

## 使用浏览器缓存

通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。

## CSS放在页面最上部，javascript放在页面最下面

## 启用压缩

在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。

# 手机端是怎么实现响应式的

## 媒体查询 
一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配。 

## 手淘flexlable H5方案，原理使用js控制根元素font-size大小

# Jquery源码

## jq链式调用

需要在要实现链式调用的方法的返回结果里，返回 this ，就能够实现链式调用了。

## jq Ajax源码分析

[jq Ajax源码分析](https://blog.csdn.net/qq_33706382/article/details/78178459)

（1）调用 jQuery.ajaxSetup( {}, options )让最终options具有jQuery内置的所有的属性，同时也包括用户调用ajax方法的时候传入的所有的属性和方法!

（2）创建jqXHR对象，让该对象具有Deferred的所有属性和方法，该Deferred对象可以绑定用户的success和error方法。但是用户传入的compelte方法表示任何情况下都会调用，我们就引入了一个Callbacks对象，把complete回调函数存入该Callback中（用fireWith调用）

（3）对URL处理，取出hash加上协议名称，为type赋值，也就是Get/Post方法(用户可以通过method或者type传入该方法);指定dataTypes说明用户需要要的数据类型(用户通过dataType传入);如果用户没有明确指定crossDomain，那么自己判断，如果用户传入的URL也就是访问的URL和当前的location.href不相同(包括协议名称，主机名，端口号等),那么直接把crossDomain设置为true;如果传入了数据，也就是data那么通过 jQuery.param方法把这个数据序列化;

（4）上述步骤完成以后，我们就调用inspectPrefiltersOrTransports，这个方法传入了prefilters，表示对prefilters中所有的预处理函数进行检测，该方法可以修改前面所有的参数，当然也可以添加新的信息!(这里是prefilters)

（5）如果用户传入了global参数，那么我们在这个步骤执行"ajaxStart"事件

## jq 样式操作

[jq 样式操作](http://www.cnblogs.com/aaronjs/p/3433358.html)
`addClass()
jQuery.cssHooks
.hasClass()
.removeClass()
.toggleClass()`

如果传递的是回调函数，递归调用  
分解下样式规则,通过正则/\S+/g 空白分组
如果元素本身存在class样式，先取出来
组合成新的规则按照空格分开
通过className 设置新的样式 

# css中单位px,em，rem和vh/vw的理解

px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。
em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)

rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。

vh、vw：相对于视口的高度和宽度，而不是父元素的(CSS百分比是相对于包含它的最近的父元素的高度和宽度)。
1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度

# html5与css3新增特性

[html5与css3新增特性](https://blog.csdn.net/lost_path/article/details/78389226)

# Ajax问题

[Ajax问题](https://blog.csdn.net/hyunbar/article/details/78500837)

# 跨域问题

[跨域问题](https://segmentfault.com/a/1190000015597029)

# ES6问题

[ES6问题](https://www.cnblogs.com/fengxiongZz/p/8191503.html)

# [Http问题]

[Http问题](https://blog.csdn.net/yicixing7/article/details/79320821)

# 17保后台管理系统

主要负责：
 使用 layUI 框架进行页面开发
 使用JavaScript 和 jQuery 完成逻辑代码
 负责与后端的API接口的数据对接，保证功能的完整实现
 基于Token身份，判断用户登录操作

因为我的前端老大，觉得layui使用起来简单，方便快速开发，与后端匹配度也很高，后端也可以拿来即用

## token与cookie的区别，在项目中是怎么样使用token的

### 区别：

基于session认证所显露的问题
Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。

CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。



### 使用方法

首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间生成 token ，返回给前端；
前端拿到后端返回的 token ,存储在 cookie；
前端每次路由跳转，判断 cookie 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态；
每次请求接口，在 请求头里携带 token;
后端接口判断请求头有无 token，没有或者 token 过期，返回401；
前端得到 401 状态码，重定向到登录页面。

### token原理

（1）用户请求时携带此token（分为三部分，header密文，payload密文，签名）到服务端，服务端解析第一部分（header密文），用Base64解密，可以知道用了什么算法进行签名，此处解析发现是HS256。

（2）服务端使用原来的秘钥与密文(header密文+"."+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。

 （3）判断是否过期，客户端通过用Base64解密第二部分（payload密文），可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期

### 遇到的问题

是在后台写的一个接口中，需要返回字段和一份文件，但每次返回的字段是undefind，原因是，
layUI框架的问题，使用formData方法正常接收到，

### 前端解析Excel和CSV文件

[前端解析Excel和CSV文件](https://juejin.im/post/5b1fdbcc5188257d571f2c62)
[文件和二进制数据的操作](http://javascript.ruanyifeng.com/htmlapi/file.html#toc1)

# 云保单2.0

## 图片上传的方法，怎么样实现上传

图片上传插件（mobileFix.mini.js[压缩质量修复 drawImage画面扭曲修复] exif.js[提供了 JavaScript 读取图像的原始数据的功能扩展，例如：拍照方向、相机设备型号、拍摄时间、ISO 感光度、GPS 地理位置等数据。] lrz.js[图片压缩]）

## 自己js实现图片上传，压缩
[图片上传，压缩](https://zhanghao-web.github.io/2018/08/07/%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87/)
[HTML5图片上传](https://sebastianblade.com/browser-side-image-compress-and-upload/)

# jsonp的原理，以及优缺点

动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本

优点：兼容性好，

缺点： 只支持get方法，发生错误不会状态码，安全问题

## 遇到的问题： 

在将拍照获得的图片进行转换成字符串编码时造成内存溢出问题，

错误原因：
转换时默认是先将图片加载到内存当中然后在进行转换，但是由于加载的图片太大，超过了要求，所以出现了内存溢出
这样的问题导致程序崩溃

解决方法：
通过在图片转换时设置这两个参数，inSampleSize对图片进行压缩，inJustDecodeBounds设置图片不加载到内存
```js
BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = size;
options.inJustDecodeBounds = false;
```

# react人员管理系统

## 介绍下这个项目，遇到了那些问题，是怎么解决的

一个基本的人员管理系统，主要功能为人员基本信息列表；人员的录入及删除；人员详细信息的查看；人
员信息的编辑；根据人员身份进行筛选；根据人员某些属性进行排序；根据人姓名、年龄、身份、性别等关键
字进行人员搜索

### 遇到的问题是

组件通信的问题，子组件触发祖父组件的事件，第一时间想到的是react-redux库，但是因为所做的项目没有必要在使用一个框架，最后选择了react 16.4的conText方法

# axios与fetch，ajax的区别  

# Sass/Scss与Less区别

编译环境不一样
变量符不同
输出设置
sass支持条件语句，less不支持

# gulp与webpack的区别

Gulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件
通过下面5种个方法就可以胜任几乎所有构建场景：

通过 gulp.task 注册一个任务；
通过 gulp.run 执行任务；
通过 gulp.watch 监听文件变化；
通过 gulp.src 读取文件；
通过 gulp.dest 写文件。

* Gulp 的优点是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。其缺点是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。

Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。

* Webpack的优点是：

专注于处理模块化的项目，能做到开箱即用一步到位；
通过 Plugin 扩展，完整好用又不失灵活；
使用场景不仅限于 Web 开发；
社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；
良好的开发体验。

Webpack的缺点是只能用于采用模块化开发的项目。

## webpack原理

1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 
2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 3.确定入口：根据配置中的 entry 找出所有的入口文件； 
4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 
5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 
6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

# 为什么不用vue，Vue与react有什么相同以及不同之处

> 相同之处

* Virtual DOM
Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。

Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。

* 组件化

React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:

* Props

在上面两个例子中，我们可以看到React和Vue都有'props'的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。

在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”（稍后有更多介绍）。

而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。

* 构建工具

* chrome开发工具

* 配套框架

> 不同之处

* 模板 vs JSX

* 状态管理 vs 对象属性

如果你对React熟悉，你就会知道应用中的状态是（React）关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变（这也许不一定正确）。在React中你需要使用setState()方法去更新状态。

在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。